**I'm adding this library into a new more complex github repo as an external library. I want to build it separately,
once, or when updated, but I don't want to install it outside my new repo/project. What's the best way to do that and be
able to easily use the library in the new repo/project?**

The best practice in CMake is:

**Put a separate `CMakeLists.txt` in each subdirectory**.

---

### **Why this is preferable:**

1. **Clean organization**:

    * Each directory clearly describes what it builds.
    * Easy navigation, maintenance, and readability.

2. **Modular builds**:

    * Clearly defined dependencies and visibility.
    * Simple reuse or disabling of certain modules.

3. **Scalability**:

    * Easier to add/remove modules later.
    * Easier integration with tests or documentation per directory.

---

### **Typical structure:**

Here's how your directory structure should look:

```
libdap4/
‚îú‚îÄ‚îÄ CMakeLists.txt            # Top-level
‚îú‚îÄ‚îÄ gl/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt        # For 'gl' sources
‚îú‚îÄ‚îÄ d4_ce/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt        # For 'd4_ce' sources
‚îú‚îÄ‚îÄ d4_function/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ http_dap/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ unit-tests/               # Later for tests, if needed
‚îú‚îÄ‚îÄ tests/                    # Later for tests or scripts
‚îî‚îÄ‚îÄ src/                      # Top-level sources, if any
```

---

### **Example: top-level `CMakeLists.txt`**

Your top-level CMakeLists.txt references the subdirectories clearly:

```cmake
cmake_minimum_required(VERSION 3.10)
project(libdap4)

# Include common settings, compiler flags, find_package, etc.

add_subdirectory(gl)
add_subdirectory(d4_ce)
add_subdirectory(d4_function)
add_subdirectory(http_dap)

# Include unit-tests and tests directories as needed later:
# add_subdirectory(unit-tests)
# add_subdirectory(tests)

# Define top-level libraries/executables linking against subdirectory targets.
```

---

### **Example: `d4_ce/CMakeLists.txt` (a typical subdir)**

```cmake
# d4_ce/CMakeLists.txt
add_library(d4_ce STATIC
		parser.cc
		helper.cc
)

target_include_directories(d4_ce PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# Link or expose dependencies if any.
```

---

### **Advantages over one big top-level CMakeLists.txt:**

| Aspect       | Separate Subdir files          | One Big File                 |
|--------------|--------------------------------|------------------------------|
| Clarity      | ‚úÖ Clear and maintainable       | ‚ùå Cluttered and hard to read |
| Modularity   | ‚úÖ Easy to add/remove modules   | ‚ùå More complex maintenance   |
| Scalability  | ‚úÖ Easier long-term maintenance | ‚ùå Becomes unwieldy quickly   |
| Dependencies | ‚úÖ Clearly scoped per subdir    | ‚ùå Easy to mix/confuse deps   |

---

### **Conclusion:**

Placing a `CMakeLists.txt` in each subdirectory and referencing via `add_subdirectory` from the top-level
`CMakeLists.txt` is strongly recommended for readability, maintainability, modularity, and scalability.

# Building _config_dap.h_ from _config_dap.h.in_

In CMake, the standard and recommended way to handle this situation‚Äîwhere a header file is generated from
configuration tests‚Äîis through `configure_file()` and `check_include_files()`, `check_symbol_exists()`, or
`check_cxx_source_compiles()` for feature testing.

Here's a clear and concise approach:

---

## Step-by-Step Example

### ‚ë† Create `config_dap.h.in`

Similar to your existing Autotools setup (`config_dap.h.in`), create something like:

```c
/* config_dap.h.in - Generated by CMake from tests */

#cmakedefine HAVE_LIBXML2
#cmakedefine HAVE_CURL
#cmakedefine HAVE_TIRPC
#cmakedefine HAVE_PTHREADS

#cmakedefine ENABLE_ASAN
#cmakedefine BUILD_DEVELOPER

/* version information */
#define LIBDAP_VERSION "@LIBDAP_VERSION@"
#define PACKAGE_NAME "@PROJECT_NAME@"
#define PACKAGE_VERSION "@PROJECT_VERSION@"
```

* The `#cmakedefine` directive means CMake will define these macros if the condition is met, or comment them out
  otherwise.
* `@VAR@` placeholders will be replaced with actual values.

---

### ‚ë° Add Feature Tests in `CMakeLists.txt`

Use built-in checks for includes and symbols:

```cmake
include(CheckIncludeFiles)
include(CheckLibraryExists)
include(CheckSymbolExists)
include(CheckCXXSourceCompiles)

# Example checks
check_include_files("libxml/parser.h" HAVE_LIBXML2)
check_include_files("curl/curl.h" HAVE_CURL)
check_include_files("tirpc/rpc/rpc.h" HAVE_TIRPC)

check_symbol_exists(pthread_create pthread.h HAVE_PTHREADS)

# Optional ASAN and Developer mode flags (based on CMake options)
option(ENABLE_ASAN "Enable Address Sanitizer" OFF)
option(BUILD_DEVELOPER "Build in developer mode" OFF)

# Set your project and version information clearly
set(LIBDAP_VERSION "1.0.0") # Replace as appropriate
```

---

### ‚ë¢ Generate `config_dap.h` via `configure_file`

Use `configure_file()` in your main `CMakeLists.txt`:

```cmake
configure_file(
		"${CMAKE_CURRENT_SOURCE_DIR}/config_dap.h.in"
		"${CMAKE_CURRENT_BINARY_DIR}/config_dap.h"
)
```

Now `config_dap.h` is generated at configuration time (`cmake ..`).

---

### ‚ë£ Include the generated header directory in your targets

Make sure your targets include this directory for compilation:

```cmake
target_include_directories(your_library_target PUBLIC
		${CMAKE_CURRENT_BINARY_DIR}
)
```

* This ensures `#include "config_dap.h"` is resolved during compilation.

---

### ‚ë§ Example Result (`config_dap.h` generated)

After configuration, you'll see something like:

```c
/* config_dap.h - Generated by CMake from tests */

#define HAVE_LIBXML2
#define HAVE_CURL
/* #undef HAVE_TIRPC */

#define HAVE_PTHREADS

/* #undef ENABLE_ASAN */
#define BUILD_DEVELOPER

/* version information */
#define LIBDAP_VERSION "1.0.0"
#define PACKAGE_NAME "libdap"
#define PACKAGE_VERSION "1.0.0"
```

---

## **How this clearly mimics your Autotools workflow:**

| Autotools Step                   | CMake Equivalent                      |
|----------------------------------|---------------------------------------|
| `AC_CHECK_HEADERS([libxml/...])` | `check_include_files()`               |
| `AC_DEFINE([HAVE_LIBXML2], ...)` | `configure_file()` + `#cmakedefine`   |
| `AC_SUBST(VERSION)`              | `set(PROJECT_VERSION "x.y.z")`        |
| Generate `config_dap.h`          | `configure_file(config_dap.h.in ...)` |

---

## **Key advantages of using `configure_file()` in CMake:**

* Clear and readable configuration process.
* Integrates naturally with standard CMake practices.
* Automatic regeneration only when configuration changes.

This approach cleanly replaces your Autotools header-generation logic, maintaining clarity, maintainability, and
seamless integration with CMake.

# More about Flex ande Bison

This error:

```
c++: error: no such file or directory: '/Users/jimg/src/opendap/skunk/build/libdap/lex.dds.cc'
```

means CMake is trying to compile `lex.dds.cc` **before it's generated by Flex**. Even if you've written the correct
`FLEX_TARGET()` declaration, this happens when:

1. You **directly list `lex.dds.cc`** in your source list (e.g., `add_library(libparsers ... lex.dds.cc)`), or
2. You **don't use** the `FLEX_TARGET()` variables correctly in your `add_library()`.

---

### ‚úÖ Fix: Use the CMake-generated output from `FLEX_TARGET()` and `BISON_TARGET()`

Suppose your grammar is defined as:

```cmake
BISON_TARGET(DDSParser dds.yy ${CMAKE_CURRENT_BINARY_DIR}/dds.tab.cc
		DEFINES_FILE ${CMAKE_CURRENT_BINARY_DIR}/dds.tab.hh)

FLEX_TARGET(DDSScanner dds.lex ${CMAKE_CURRENT_BINARY_DIR}/lex.dds.cc)

ADD_FLEX_BISON_DEPENDENCY(DDSScanner DDSParser)
```

These macros define:

* `BISON_DDSParser_OUTPUT_SOURCE` ‚Üí the `.cc` file
* `BISON_DDSParser_OUTPUT_HEADER` ‚Üí the `.hh` file
* `FLEX_DDSScanner_OUTPUTS` ‚Üí the `.cc` file

Then you must **build your library using these CMake variables**, like this:

```cmake
add_library(libparsers STATIC
		${BISON_DDSParser_OUTPUT_SOURCE}
		${BISON_DDSParser_OUTPUT_HEADER}
		${FLEX_DDSScanner_OUTPUTS}
		# any other hand-written sources
)
```

This ensures:

* CMake knows the file doesn‚Äôt exist yet.
* It ensures correct build order.
* It prevents trying to compile missing files too early.

---

### üö´ Don't do this:

```cmake
add_library(libparsers STATIC
		lex.dds.cc   # ‚ùå BAD: hard-coded reference to a generated file
		dds.tab.cc   # ‚ùå BAD: same problem
)
```

---

### ‚úÖ Also include the generated header:

If other source files include `dds.tab.hh`, add:

```cmake
target_include_directories(libparsers PRIVATE
		${CMAKE_CURRENT_BINARY_DIR}
)
```

This tells the compiler where to find the generated `.hh` file.

---

### üîÅ Recap ‚Äì What You Should Check

* [ ] No hardcoded references like `lex.dds.cc` or `dds.tab.cc` in your `add_library()` or `add_executable()`.
* [ ] You're using `${FLEX_*_OUTPUTS}` and `${BISON_*}` variables instead.
* [ ] `configure_file()` or `include_directories()` covers the generated headers.

---

Once fixed, delete your build directory (just to be safe) and re-run:

```bash
rm -rf build
mkdir build && cd build
cmake ..
make -j
```

That should resolve the error. Let me know if you‚Äôd like help verifying or checking for similar issues in other grammar
files.

**CMake settings like `target_compile_options()` or `target_link_options()` do *not* automatically propagate to child
directories or targets declared in subdirectories**, unless you explicitly structure them to do so.

Here's how it works and how you can manage it effectively:

---

## üîç What happens by default

When you do:

```cmake
add_subdirectory(subdir)
```

* That subdir gets its own `CMakeLists.txt` context.
* Any **targets defined in that subdir** (`add_library()`, `add_executable()`) **do not inherit** compile options,
  include paths, or link options from the parent.

So if you only write:

```cmake
target_compile_options(dap PRIVATE -g3 -O0 ...)
```

That affects only the `dap` target ‚Äî not `d4_ce_parser`, `http_dap`, etc., even if they are part of your build and even
if they link to `dap`.

---

## ‚úÖ How to Make Compiler Options Apply Project-Wide

### Option 1: Define shared flags in variables and apply per target

You‚Äôve already done this in your example:

```cmake
set(COMMON_COMPILE_FLAGS -g3 -O0 -Wall -Wcast-align)
target_compile_options(my_target PRIVATE ${COMMON_COMPILE_FLAGS})
```

Then reuse that across subdirectories via `target_compile_options()`.

üëâ This is clean, explicit, and CMake-friendly.

---

### Option 2: Use `INTERFACE` targets for propagation

Create an interface target to hold compile and link options:

```cmake
add_library(common_build_flags INTERFACE)

target_compile_options(common_build_flags INTERFACE ${DEV_FLAGS})
target_link_options(common_build_flags INTERFACE ${ASAN_LINK_FLAGS})
```

Then in subdirectories:

```cmake
target_link_libraries(d4_ce_parser PRIVATE common_build_flags)
target_link_libraries(http_dap PRIVATE common_build_flags)
```

üëâ This is very CMake-idiomatic and works well for large projects.

---

### Option 3: Use `CMAKE_CXX_FLAGS` globally (not recommended)

You *can* set global flags like:

```cmake
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wcast-align")
```

But this applies to **every** target, even third-party ones, and doesn't respect modern target-specific scoping.

üëâ Avoid unless you're controlling the entire build and want global settings.

---

## ‚úÖ Summary

| Option                            | Applies to Subdirs?     | Recommended                                  |
|-----------------------------------|-------------------------|----------------------------------------------|
| `target_compile_options()`        | ‚ùå No                    | ‚úÖ Per-target control                         |
| `CMAKE_CXX_FLAGS`                 | ‚úÖ Yes (global)          | ‚ö†Ô∏è Use with caution                          |
| Interface target (`common_flags`) | ‚úÖ If linked             | ‚úÖ Best for reuse                             |
| `include_directories(...)`        | ‚ùå (not target-specific) | ‚ö†Ô∏è Legacy-style, discouraged in modern CMake |

---

Let me know if you'd like help setting up a `common_build_flags` target or making a shared flag module for your project.

For Option 1, will child directories be able to use ${COMMON_COMPILE_FLAGS}?

**if you explicitly make it available** ‚Äî by default, variables like `COMMON_COMPILE_FLAGS` declared in a parent
`CMakeLists.txt` are **not automatically visible in child directories** after `add_subdirectory()`.

But you can easily make them available. Here's how:

---

## ‚úÖ How to Share Variables with Child Directories

### üî∏ Option 1: Use `set(VAR value CACHE INTERNAL "")`

In the parent `CMakeLists.txt`:

```cmake
set(COMMON_COMPILE_FLAGS "-Wall -Wcast-align -g3 -O0" CACHE INTERNAL "Common compile flags")
```

This makes `COMMON_COMPILE_FLAGS` visible in all subdirectories.

Then, in a child directory's `CMakeLists.txt`:

```cmake
target_compile_options(d4_ce_parser PRIVATE ${COMMON_COMPILE_FLAGS})
```

‚úÖ **Recommended** when you're okay with global project-wide sharing of a setting.

---

### üî∏ Option 2: Pass the variable explicitly into subdirs

If you want more controlled, modular sharing:

```cmake
# Top-level CMakeLists.txt
set(COMMON_COMPILE_FLAGS "-Wall -Wcast-align -g3 -O0")
add_subdirectory(d4_ce)
```

Then in `d4_ce/CMakeLists.txt`:

```cmake
# Inherits COMMON_COMPILE_FLAGS only if still in scope
target_compile_options(d4_ce_parser PRIVATE ${COMMON_COMPILE_FLAGS})
```

‚ö†Ô∏è But this only works **if the variable remains in scope** ‚Äî which it usually does if declared just before
`add_subdirectory()`. Still, it‚Äôs not guaranteed behavior across separate `CMakeLists.txt` files unless you use the
`CACHE` method.

---

### üî∏ Option 3: Put shared logic in a file and `include()` it

Create `CommonFlags.cmake`:

```cmake
set(COMMON_COMPILE_FLAGS "-Wall -Wcast-align -g3 -O0")
```

Then:

```cmake
include(${CMAKE_SOURCE_DIR}/cmake/CommonFlags.cmake)
```

‚úÖ Best for larger projects with many reusable settings.

---

## üß† Summary

| Method                           | Inherits Automatically? | Best For                 |
|----------------------------------|-------------------------|--------------------------|
| Plain `set(VAR ...)`             | ‚ùå No                    | Small projects           |
| `set(VAR ... CACHE INTERNAL "")` | ‚úÖ Yes                   | Global project settings  |
| `include("CommonFlags.cmake")`   | ‚úÖ Yes (explicit)        | Modular, larger projects |

---

Let me know which style you'd prefer and I can sketch it out for your actual `libdap` structure.
