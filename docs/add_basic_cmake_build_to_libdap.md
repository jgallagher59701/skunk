**I'm adding this library into a new more complex github repo as an external library. I want to build it separately,
once, or when updated, but I don't want to install it outside my new repo/project. What's the best way to do that and be
able to easily use the library in the new repo/project?**

The best practice in CMake is:

**Put a separate `CMakeLists.txt` in each subdirectory**.

---

### **Why this is preferable:**

1. **Clean organization**:

    * Each directory clearly describes what it builds.
    * Easy navigation, maintenance, and readability.

2. **Modular builds**:

    * Clearly defined dependencies and visibility.
    * Simple reuse or disabling of certain modules.

3. **Scalability**:

    * Easier to add/remove modules later.
    * Easier integration with tests or documentation per directory.

---

### **Typical structure:**

Here's how your directory structure should look:

```
libdap4/
‚îú‚îÄ‚îÄ CMakeLists.txt            # Top-level
‚îú‚îÄ‚îÄ gl/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt        # For 'gl' sources
‚îú‚îÄ‚îÄ d4_ce/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt        # For 'd4_ce' sources
‚îú‚îÄ‚îÄ d4_function/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ http_dap/
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ unit-tests/               # Later for tests, if needed
‚îú‚îÄ‚îÄ tests/                    # Later for tests or scripts
‚îî‚îÄ‚îÄ src/                      # Top-level sources, if any
```

---

### **Example: top-level `CMakeLists.txt`**

Your top-level CMakeLists.txt references the subdirectories clearly:

```cmake
cmake_minimum_required(VERSION 3.10)
project(libdap4)

# Include common settings, compiler flags, find_package, etc.

add_subdirectory(gl)
add_subdirectory(d4_ce)
add_subdirectory(d4_function)
add_subdirectory(http_dap)

# Include unit-tests and tests directories as needed later:
# add_subdirectory(unit-tests)
# add_subdirectory(tests)

# Define top-level libraries/executables linking against subdirectory targets.
```

---

### **Example: `d4_ce/CMakeLists.txt` (a typical subdir)**

```cmake
# d4_ce/CMakeLists.txt
add_library(d4_ce STATIC
    parser.cc
    helper.cc
)

target_include_directories(d4_ce PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# Link or expose dependencies if any.
```

---

### **Advantages over one big top-level CMakeLists.txt:**

| Aspect       | Separate Subdir files          | One Big File                 |
| ------------ | ------------------------------ | ---------------------------- |
| Clarity      | ‚úÖ Clear and maintainable       | ‚ùå Cluttered and hard to read |
| Modularity   | ‚úÖ Easy to add/remove modules   | ‚ùå More complex maintenance   |
| Scalability  | ‚úÖ Easier long-term maintenance | ‚ùå Becomes unwieldy quickly   |
| Dependencies | ‚úÖ Clearly scoped per subdir    | ‚ùå Easy to mix/confuse deps   |

---

### **Conclusion:**

Placing a `CMakeLists.txt` in each subdirectory and referencing via `add_subdirectory` from the top-level
`CMakeLists.txt` is strongly recommended for readability, maintainability, modularity, and scalability.

# Building _config_dap.h_ from _config_dap.h.in_

In CMake, the standard and recommended way to handle this situation‚Äîwhere a header file is generated from
configuration tests‚Äîis through `configure_file()` and `check_include_files()`, `check_symbol_exists()`, or
`check_cxx_source_compiles()` for feature testing.

Here's a clear and concise approach:

---

## Step-by-Step Example

### ‚ë† Create `config_dap.h.in`

Similar to your existing Autotools setup (`config_dap.h.in`), create something like:

```c
/* config_dap.h.in - Generated by CMake from tests */

#cmakedefine HAVE_LIBXML2
#cmakedefine HAVE_CURL
#cmakedefine HAVE_TIRPC
#cmakedefine HAVE_PTHREADS

#cmakedefine ENABLE_ASAN
#cmakedefine BUILD_DEVELOPER

/* version information */
#define LIBDAP_VERSION "@LIBDAP_VERSION@"
#define PACKAGE_NAME "@PROJECT_NAME@"
#define PACKAGE_VERSION "@PROJECT_VERSION@"
```

* The `#cmakedefine` directive means CMake will define these macros if the condition is met, or comment them out otherwise.
* `@VAR@` placeholders will be replaced with actual values.

---

### ‚ë° Add Feature Tests in `CMakeLists.txt`

Use built-in checks for includes and symbols:

```cmake
include(CheckIncludeFiles)
include(CheckLibraryExists)
include(CheckSymbolExists)
include(CheckCXXSourceCompiles)

# Example checks
check_include_files("libxml/parser.h" HAVE_LIBXML2)
check_include_files("curl/curl.h" HAVE_CURL)
check_include_files("tirpc/rpc/rpc.h" HAVE_TIRPC)

check_symbol_exists(pthread_create pthread.h HAVE_PTHREADS)

# Optional ASAN and Developer mode flags (based on CMake options)
option(ENABLE_ASAN "Enable Address Sanitizer" OFF)
option(BUILD_DEVELOPER "Build in developer mode" OFF)

# Set your project and version information clearly
set(LIBDAP_VERSION "1.0.0") # Replace as appropriate
```

---

### ‚ë¢ Generate `config_dap.h` via `configure_file`

Use `configure_file()` in your main `CMakeLists.txt`:

```cmake
configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/config_dap.h.in"
    "${CMAKE_CURRENT_BINARY_DIR}/config_dap.h"
)
```

Now `config_dap.h` is generated at configuration time (`cmake ..`).

---

### ‚ë£ Include the generated header directory in your targets

Make sure your targets include this directory for compilation:

```cmake
target_include_directories(your_library_target PUBLIC
    ${CMAKE_CURRENT_BINARY_DIR}
)
```

* This ensures `#include "config_dap.h"` is resolved during compilation.

---

### ‚ë§ Example Result (`config_dap.h` generated)

After configuration, you'll see something like:

```c
/* config_dap.h - Generated by CMake from tests */

#define HAVE_LIBXML2
#define HAVE_CURL
/* #undef HAVE_TIRPC */

#define HAVE_PTHREADS

/* #undef ENABLE_ASAN */
#define BUILD_DEVELOPER

/* version information */
#define LIBDAP_VERSION "1.0.0"
#define PACKAGE_NAME "libdap"
#define PACKAGE_VERSION "1.0.0"
```

---

## **How this clearly mimics your Autotools workflow:**

| Autotools Step                   | CMake Equivalent                      |
| -------------------------------- | ------------------------------------- |
| `AC_CHECK_HEADERS([libxml/...])` | `check_include_files()`               |
| `AC_DEFINE([HAVE_LIBXML2], ...)` | `configure_file()` + `#cmakedefine`   |
| `AC_SUBST(VERSION)`              | `set(PROJECT_VERSION "x.y.z")`        |
| Generate `config_dap.h`          | `configure_file(config_dap.h.in ...)` |

---

## **Key advantages of using `configure_file()` in CMake:**

* Clear and readable configuration process.
* Integrates naturally with standard CMake practices.
* Automatic regeneration only when configuration changes.

This approach cleanly replaces your Autotools header-generation logic, maintaining clarity, maintainability, and seamless integration with CMake.

# More about Flex ande Bison

This error:

```
c++: error: no such file or directory: '/Users/jimg/src/opendap/skunk/build/libdap/lex.dds.cc'
```

means CMake is trying to compile `lex.dds.cc` **before it's generated by Flex**. Even if you've written the correct `FLEX_TARGET()` declaration, this happens when:

1. You **directly list `lex.dds.cc`** in your source list (e.g., `add_library(libparsers ... lex.dds.cc)`), or
2. You **don't use** the `FLEX_TARGET()` variables correctly in your `add_library()`.

---

### ‚úÖ Fix: Use the CMake-generated output from `FLEX_TARGET()` and `BISON_TARGET()`

Suppose your grammar is defined as:

```cmake
BISON_TARGET(DDSParser dds.yy ${CMAKE_CURRENT_BINARY_DIR}/dds.tab.cc
             DEFINES_FILE ${CMAKE_CURRENT_BINARY_DIR}/dds.tab.hh)

FLEX_TARGET(DDSScanner dds.lex ${CMAKE_CURRENT_BINARY_DIR}/lex.dds.cc)

ADD_FLEX_BISON_DEPENDENCY(DDSScanner DDSParser)
```

These macros define:

* `BISON_DDSParser_OUTPUT_SOURCE` ‚Üí the `.cc` file
* `BISON_DDSParser_OUTPUT_HEADER` ‚Üí the `.hh` file
* `FLEX_DDSScanner_OUTPUTS` ‚Üí the `.cc` file

Then you must **build your library using these CMake variables**, like this:

```cmake
add_library(libparsers STATIC
    ${BISON_DDSParser_OUTPUT_SOURCE}
    ${BISON_DDSParser_OUTPUT_HEADER}
    ${FLEX_DDSScanner_OUTPUTS}
    # any other hand-written sources
)
```

This ensures:

* CMake knows the file doesn‚Äôt exist yet.
* It ensures correct build order.
* It prevents trying to compile missing files too early.

---

### üö´ Don't do this:

```cmake
add_library(libparsers STATIC
    lex.dds.cc   # ‚ùå BAD: hard-coded reference to a generated file
    dds.tab.cc   # ‚ùå BAD: same problem
)
```

---

### ‚úÖ Also include the generated header:

If other source files include `dds.tab.hh`, add:

```cmake
target_include_directories(libparsers PRIVATE
    ${CMAKE_CURRENT_BINARY_DIR}
)
```

This tells the compiler where to find the generated `.hh` file.

---

### üîÅ Recap ‚Äì What You Should Check

* [ ] No hardcoded references like `lex.dds.cc` or `dds.tab.cc` in your `add_library()` or `add_executable()`.
* [ ] You're using `${FLEX_*_OUTPUTS}` and `${BISON_*}` variables instead.
* [ ] `configure_file()` or `include_directories()` covers the generated headers.

---

Once fixed, delete your build directory (just to be safe) and re-run:

```bash
rm -rf build
mkdir build && cd build
cmake ..
make -j
```

That should resolve the error. Let me know if you‚Äôd like help verifying or checking for similar issues in other grammar files.
